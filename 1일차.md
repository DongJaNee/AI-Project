# 구매패턴을 통한 이탈고객 예측
### 데이터 셋 준비
데이터셋 구성 파일들

- customers.csv : 고객정보
- sales.csv : 판매정보
- products.csv : 상품정보

개발 도구
- colab
- python

### 1. 데이터 파일 업로드
```
 ! wget 'https://drive.google.com/uc?export=download&id=1TgJlz5AKMhhZOYQY7l3fNBhPbqb5ZVq4'  -O customer_churn.zip
 ! unzip customer_churn.zip
 ! ls *.csv
 customers.csv  products.csv  sales.csv
```

<img width="590" height="667" alt="image" src="https://github.com/user-attachments/assets/a1cbcf63-ff39-4d95-a7ca-27e50a6dd7f0" />

### 2-1 customers.csv에서 2014 ~ 2016년에 등록한 고객들을 골라 cust01 데이터프레임으로 저장
```
customers_df['RegisterDate'] = pd.to_datetime(customers_df['RegisterDate'])
cust01 = customers_df[(customers_df['RegisterDate'].dt.year >= 2014) & (customers_df['RegisterDate'].dt.year <= 2016)]
display(cust01.head())
```

<img width="578" height="207" alt="image" src="https://github.com/user-attachments/assets/2b18077d-2853-4de2-bebb-b03f31c4b6cc" />

### 2-2 sales.csv에서 2016년 하반기에 주문한 히스토리가 있는 고객들의 sales 정보를 골라 cust02 데이터프레임으로 저장
```
sales_df['OrderDate'] = pd.to_datetime(sales_df['OrderDate'])
cust02 = sales_df[(sales_df['OrderDate'].dt.year == 2016) & (sales_df['OrderDate'].dt.month >= 7)]
display(cust02.head())
```

<img width="605" height="198" alt="image" src="https://github.com/user-attachments/assets/d34c3f04-a52d-4bb9-aafc-18d8820ea35f" />

### 2-3 cust02에서 CustomerID가 중복된 행들은 중복 제거를 하고 다시 cust02로 저장
```
cust02 = cust02.drop_duplicates(subset=['CustomerID'])
display(cust02.head())
```


<img width="549" height="198" alt="image" src="https://github.com/user-attachments/assets/14aef0e9-c8e6-44b1-81e1-03d66943d8d7" />

### 3. cust01와 cust02 데이터프레임을 CustomerID를 기준으로, cust01과 cust02의 고객 정보가 모두 포함되도록 병합하여 cust_churn0으로 저장
```
cust_churn0 = pd.merge(cust01, cust02, on='CustomerID', how='inner')
display(cust_churn0.head())
```


<img width="882" height="196" alt="image" src="https://github.com/user-attachments/assets/a854a147-7dfc-4028-9ec5-6cd75bdea64b" />

### 4. 현재 table에 속성 churn 생성
```
# churn 컬럼의 정의: 1이면 이탈 고객, 0이면 비이탈 고객
# 초기값은 0
cust_churn0['Churn'] = 0
display(cust_churn0.head())
```


<img width="918" height="198" alt="image" src="https://github.com/user-attachments/assets/119d370b-5aa2-48ce-8288-19b3ce300b7e" />



---
# IBM AutoAI UI

개발 도구 
- Colap(Python)
- Streamlit

바이브 코딩 필요한 영역 
1. api_key와 endpoint_url 입력창 만들기
2. 검진 결과 입력창 8개 추가하기
3. IBM 클라우드 access_token 생성하기
4. “결과 예측” 버튼을 클릭하면 endpoint_url이 반환해주는 머신러닝 모델 예측값을 브라우저에 출력하기
api_key를 입력하는 창에 입력하는 값은 보안을 위하여 masking되도록  설정하십시오.

### 1. Streamlit install 
cmd
```
C:\pip install streamlit


C:\pip show streamlit
Name: streamlit
Version: 1.48.1
Summary: A faster way to build and share data apps
Home-page: https://streamlit.io
Author: Snowflake Inc
Author-email: hello@streamlit.io
License: Apache License 2.0
Location: C:\Users\chdae\Documents\GK\2025\IBM\대증소상생아카데미\streamlit\autoai\Lib\site-packages
Requires: altair, blinker, cachetools, click, gitpython, numpy, packaging, pandas, pillow, protobuf, pyarrow, pydeck, requests, tenacity, toml, tornado, typing-extensions, watchdog
Required-by

```

설치 성공확인
```
C:\>streamlit hello
```


<img width="795" height="643" alt="image" src="https://github.com/user-attachments/assets/8564e0e0-cd23-49f8-a580-26bb4fd835c4" />


### 2. 바이브 코딩 소스 코드 

```
import requests
#import pandas as pd
import streamlit as st

def web_app():
    st.write("""
    # 유방암 진단 앱
   """)

    ### 1. api_key와 endpoint_url 입력창 만들기 바이브 코딩
    
    
    ### end of 1


    st.header("검진 결과 입력창")

    cell_shape = st.number_input("Uniformity of Cell Shape", 0, 10, value=1)
    ### 2.  나머지 8개의 입력창 생성을 위한 코드
    
    
    ### end of 2

    if st.button("결과 예측"):
        if not api_key or not endpoint_url:
            st.error("Please enter both API Key and Endpoint URL in the sidebar.")
            return

        try:
            ### 3. IBM 클라우드 access_token 생성하기 바이브코딩
            
            
            ### end of 3
           
            # Create input values array
            input_values = [cell_shape, clump_thickness, cell_size, marginal_adhesion,
                           single_epithelial_cell_size, bare_nuclei, bland_chromatin,
                           normal_nucleoli, mitosis]

            # Prepare payload for scoring
            payload_scoring = {
                "input_data": [{
                    "fields": ["Clump Thickness",
                                "Uniformity of Cell Size",
                                "Uniformity of Cell Shape",
                                "Marginal Adhesion",
                                "Single Epithelial Cell Size",
                                "Bare Nuclei",
                                "Bland Chromatin",
                                "Normal Nucleoli",
                                "Mitoses"],
                    "values": [input_values]
                }]
            }

            ### 4. “결과 예측” 버튼을 클릭하면 endpoint_url이 반환해주는 머신러닝 모델 예측값을 브라우저에 출력하기 가져오기 바이브 코딩


            ### end of 4

            # Convert result to readable format
            if result == 2:
                result_text = "Benign"
            else:
                result_text = "Malignant"

            st.text_area(label='Cancer is:- ', value=result_text, height=100)

        except Exception as e:
            st.error(f"An error occurred while making the prediction: {str(e)}")
            st.info("Please check your internet connection, API Key, and Endpoint URL and try again.")

# Run the web app
web_app()
```

### 3. 완성된 소스코드 
```
import requests
#import pandas as pd
import streamlit as st

def web_app():
    st.write("""
    # 유방암 진단 앱
   """)

    ### 1. api_key와 endpoint_url 입력창 만들기 바이브 코딩
    api_key = st.sidebar.text_input("IBM Cloud API Key", type="password", value="API 키 입력")
    endpoint_url = st.sidebar.text_input("IBM Cloud Endpoint URL", value="https://(url 입력)")

    ### end of 1


    st.header("검진 결과 입력창")

    cell_shape = st.number_input("Uniformity of Cell Shape", 0, 10, value=1)
    ### 2.  나머지 8개의 입력창 생성을 위한 코드
    clump_thickness = st.number_input("Clump Thickness", 0, 10, value=1)
    cell_size = st.number_input("Uniformity of Cell Size", 0, 10, value=1)
    marginal_adhesion = st.number_input("Marginal Adhesion", 0, 10, value=1)
    single_epithelial_cell_size = st.number_input("Single Epithelial Cell Size", 0, 10, value=1)
    bare_nuclei = st.number_input("Bare Nuclei", 0, 10, value=1)
    bland_chromatin = st.number_input("Bland Chromatin", 0, 10, value=1)
    normal_nucleoli = st.number_input("Normal Nucleoli", 0, 10, value=1)
    mitosis = st.number_input("Mitoses", 0, 10, value=1)


    ### end of 2

    if st.button("결과 예측"):
        if not api_key or not endpoint_url:
            st.error("Please enter both API Key and Endpoint URL in the sidebar.")
            return

        try:
            ### 3. IBM 클라우드 access_token 생성하기 바이브코딩
            # Authenticate to get the access token
            iam_url = "https://iam.cloud.ibm.com/identity/token"
            headers = {"Content-Type": "application/x-www-form-urlencoded"}
            data = f"apikey={api_key}&grant_type=urn:ibm:params:oauth:grant-type:apikey"
            iam_response = requests.post(iam_url, headers=headers, data=data)
            iam_response.raise_for_status() # Raise an exception for bad status codes
            access_token = iam_response.json()["access_token"]

            ### end of 3

            # Create input values array
            input_values = [cell_shape, clump_thickness, cell_size, marginal_adhesion,
                           single_epithelial_cell_size, bare_nuclei, bland_chromatin,
                           normal_nucleoli, mitosis]

            # Prepare payload for scoring
            payload_scoring = {
                "input_data": [{
                    "fields": ["Clump Thickness",
                                "Uniformity of Cell Size",
                                "Uniformity of Cell Shape",
                                "Marginal Adhesion",
                                "Single Epithelial Cell Size",
                                "Bare Nuclei",
                                "Bland Chromatin",
                                "Normal Nucleoli",
                                "Mitoses"],
                    "values": [input_values]
                }]
            }

            ### 4. “결과 예측” 버튼을 클릭하면 endpoint_url이 반환해주는 머신러닝 모델 예측값을 브라우저에 출력하기 가져오기 바이브 코딩
            # Make prediction request
            headers = {"Content-Type": "application/json", "Authorization": f"Bearer {access_token}"}
            response_scoring = requests.post(endpoint_url, json=payload_scoring, headers=headers)
            response_scoring.raise_for_status() # Raise an exception for bad status codes
            result = response_scoring.json()["predictions"][0]["values"][0][0]

            ### end of 4

            # Convert result to readable format
            if result == 2:
                result_text = "Benign"
            else:
                result_text = "Malignant"

            st.text_area(label='Cancer is:- ', value=result_text, height=100)

        except Exception as e:
            st.error(f"An error occurred while making the prediction: {str(e)}")
            st.info("Please check your internet connection, API Key, and Endpoint URL and try again.")

# Run the web app
web_app()
```



